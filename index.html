<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR Trash Sorting Game</title>
    <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.2/dist/mindar-image-aframe.prod.js"></script>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      }
      
      a-scene {
        width: 100vw;
        height: 100vh;
      }
      
      #ui-overlay {
        position: fixed;
        top: 10px;
        left: 10px;
        z-index: 1000;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 15px;
        border-radius: 10px;
        font-size: 14px;
        max-width: 300px;
      }
      
      #score-display {
        font-size: 24px;
        font-weight: bold;
        margin-bottom: 10px;
        color: white;
      }
      
      #instructions {
        font-size: 12px;
        color: #aaa;
        line-height: 1.5;
      }
      
      .score-board {
        position: fixed;
        top: 20px;
        right: 20px;
        background: rgba(255, 255, 255, 0.9);
        padding: 15px 25px;
        border-radius: 12px;
        font-size: 24px;
        font-weight: bold;
        color: #333;
        box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        z-index: 20;
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      
      .score-label { 
        font-size: 14px; 
        color: #666; 
        text-transform: uppercase; 
        letter-spacing: 1px; 
      }
      
      .score-value { 
        font-size: 36px; 
        color: #2563eb; 
      }
      
      .ui-container {
        position: fixed;
        bottom: 20px;
        left: 0;
        width: 100%;
        display: flex;
        justify-content: center;
        gap: 15px;
        z-index: 10;
        pointer-events: none;
      }
      
      .btn {
        pointer-events: auto;
        padding: 12px 24px;
        border: none;
        border-radius: 50px;
        font-weight: bold;
        color: white;
        cursor: pointer;
        box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        transition: transform 0.1s, filter 0.1s;
        font-size: 1rem;
      }
      
      .btn:active { 
        transform: scale(0.95); 
      }
      
      .btn-kertas { 
        background-color: #3b82f6; 
      }
      
      .btn-organik { 
        background-color: #22c55e; 
      }
      
      .btn-anorganik { 
        background-color: #ef4444; 
      }
      
      .feedback {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 48px;
        font-weight: 900;
        text-shadow: 0 4px 10px rgba(0,0,0,0.5);
        pointer-events: none;
        z-index: 30;
        opacity: 0;
        transition: opacity 0.3s;
      }
      
      .feedback.correct { 
        color: #22c55e; 
      }
      
      .feedback.wrong { 
        color: #ef4444; 
      }
      
      .feedback.show { 
        opacity: 1; 
        animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); 
      }

      .instruction {
        position: fixed;
        top: 100px;
        width: 100%;
        text-align: center;
        color: white;
        font-size: 18px;
        text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        pointer-events: none;
        z-index: 15;
      }
      
      #throw-indicator {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(76, 175, 80, 0.9);
        color: white;
        padding: 15px 30px;
        border-radius: 50px;
        font-size: 16px;
        font-weight: bold;
        z-index: 1000;
        animation: popIn 0.3s ease-out;
      }

      .hidden {
        display: none !important;
      }

      @keyframes popIn {
        0% { 
          transform: translate(-50%, -50%) scale(0.5); 
          opacity: 0;
        }
        100% { 
          transform: translate(-50%, -50%) scale(1); 
          opacity: 1;
        }
      }
      
      @keyframes popupIn {
        from {
          transform: translate(-50%, -50%) scale(0.5);
          opacity: 0;
        }
        to {
          transform: translate(-50%, -50%) scale(1);
          opacity: 1;
        }
      }

      @keyframes popupOut {
        from {
          transform: translate(-50%, -50%) scale(1);
          opacity: 1;
        }
        to {
          transform: translate(-50%, -50%) scale(0.5);
          opacity: 0;
        }
      }
    </style>
  </head>
  <body>
    
    <div id="ui-overlay">
      <div id="score-display">Score: 0</div>
      <div id="instructions">
        üì± Point camera at target marker<br>
        üóëÔ∏è Click trash type button<br>
        üëÜ Tap the correct bin!<br>
        üéØ Match trash to bin for points!
      </div>
    </div>
    
    <div class="instruction" id="instruction">
      Choose trash type, then tap the correct bin!
    </div>

    <div id="feedback" class="feedback"></div>
    
    <div id="throw-indicator" class="hidden">
      TAP to THROW! üéØ
    </div>
    
    <button id="recenter-btn" class="hidden" style="position: fixed; bottom: 20px; right: 20px; padding: 15px 25px; background: rgba(33, 150, 243, 0.9); color: white; border: none; border-radius: 50px; font-size: 16px; font-weight: bold; cursor: pointer; z-index: 1000; box-shadow: 0 4px 8px rgba(0,0,0,0.3);">
      üìç RECENTER
    </button>

    <div class="ui-container">
      <button class="btn btn-kertas" onclick="spawnTrash('kertas')">Paper Waste</button>
      <button class="btn btn-organik" onclick="spawnTrash('organik')">Organic Waste</button>
      <button class="btn btn-anorganik" onclick="spawnTrash('anorganik')">Inorganic Waste</button>
    </div>

    <a-scene 
      mindar-image="imageTargetSrc: ./assets/targets.mind; autoStart: true; uiLoading: yes; uiScanning: yes; uiError: yes;"
      color-space="sRGB"
      renderer="colorManagement: true, physicallyCorrectLights"
      vr-mode-ui="enabled: false"
      device-orientation-permission-ui="enabled: false">
      
      <a-assets>
        <a-asset-item id="bin-organik-asset" src="./assets/models/bin-organik.glb"></a-asset-item>
        <a-asset-item id="bin-anorganik-asset" src="./assets/models/bin-anorganik.glb"></a-asset-item>
        <a-asset-item id="bin-kertas-asset" src="./assets/models/bin-kertas.glb"></a-asset-item>
        <a-asset-item id="trash-organik-asset" src="./assets/models/trash-organik.glb"></a-asset-item>
        <a-asset-item id="trash-anorganik-asset" src="./assets/models/trash-anorganik.glb"></a-asset-item>
        <a-asset-item id="trash-kertas-asset" src="./assets/models/trash-kertas.glb"></a-asset-item>
      </a-assets>
      
      <a-camera position="0 0 0" look-controls="enabled: false" cursor="fuse: false; rayOrigin: mouse;" raycaster="objects: .clickable">
        <a-entity id="trash-holder" position="0 -0.5 -1"></a-entity>
      </a-camera>
      
      <a-entity light="type: ambient; color: #BBB; intensity: 0.8;"></a-entity>
      <a-entity light="type: directional; color: #FFF; intensity: 0.6" position="-0.5 1 1"></a-entity>
      
      <a-entity id="world-anchor"></a-entity>
      
      <a-entity id="marker" mindar-image-target="targetIndex: 0" visible="false">
        <a-box position="0 -0.3 0" width="2" height="0.1" depth="1.5" color="#333" opacity="0.3"></a-box>
        
        <a-entity position="-0.9 0 0" class="bin-container">
          <a-gltf-model 
            class="bin-model clickable collidable" 
            data-bin-type="kertas" 
            src="#bin-kertas-asset" 
            position="0 -0.05 0" 
            scale="0.5 0.5 0.5">
          </a-gltf-model>
          <a-text value="PAPER" color="white" align="center" width="0.8" position="0 0.3 0" rotation="0 0 0"></a-text>
        </a-entity>
        
        <a-entity position="0 0 0" class="bin-container">
          <a-gltf-model 
            class="bin-model clickable collidable" 
            data-bin-type="organik" 
            src="#bin-organik-asset" 
            position="0 -0.05 0" 
            scale="0.5 0.5 0.5">
          </a-gltf-model>
          <a-text value="ORGANIC" color="white" align="center" width="0.8" position="0 0.3 0" rotation="0 0 0"></a-text>
        </a-entity>

        <a-entity position="0.9 0 0" class="bin-container">
          <a-gltf-model 
            class="bin-model clickable collidable" 
            data-bin-type="anorganik" 
            src="#bin-anorganik-asset" 
            position="0 -0.05 0" 
            scale="0.5 0.5 0.5">
          </a-gltf-model>
          <a-text value="INORGANIC" color="white" align="center" width="0.8" position="0 0.3 0" rotation="0 0 0"></a-text>
        </a-entity>
      </a-entity>
    </a-scene>

    <script>
      const worldTrackingState = {
        hasSpawned: false,           
        isLocked: false,             
        markerEl: null,              
        worldAnchor: null,           
        persistentGroup: null,       
        recenterBtn: null            
      };

      function initWorldAnchorSystem() {
        console.log('%cüåç World Anchor System Initializing...', 'color: #00BCD4; font-size: 16px; font-weight: bold;');
        
        worldTrackingState.markerEl = document.querySelector('#marker');
        worldTrackingState.worldAnchor = document.querySelector('#world-anchor');
        worldTrackingState.recenterBtn = document.querySelector('#recenter-btn');
        
        if (!worldTrackingState.markerEl || !worldTrackingState.worldAnchor) {
          console.error('‚ùå Required elements not found!');
          return;
        }
        
        setupWorldTrackingListeners();
        setupRecenterButton();
        
        console.log('‚úÖ World Anchor System Ready!');
      }

      function setupWorldTrackingListeners() {
        const marker = worldTrackingState.markerEl;
        
        marker.addEventListener('targetFound', () => {
          console.log('%c‚úÖ MARKER FOUND!', 'color: #4CAF50; font-size: 14px; font-weight: bold;');
          
          if (!worldTrackingState.hasSpawned) {
            console.log('üéØ First detection - Spawning objects...');
            spawnAndLockObjects();
          } else if (worldTrackingState.hasSpawned && !worldTrackingState.isLocked) {
            console.log('üìç Objects already spawned - Show recenter option');
            showRecenterButton();
          }
          
          if (typeof gameState !== 'undefined') {
            gameState.isMarkerVisible = true;
          }
          showThrowHint();
        });
        
        marker.addEventListener('targetLost', () => {
          console.log('%c‚ö†Ô∏è MARKER LOST', 'color: #FF9800; font-size: 14px;');
          
          if (typeof gameState !== 'undefined') {
            gameState.isMarkerVisible = false;
          }
          
          if (worldTrackingState.hasSpawned) {
            console.log('‚úÖ Objects remain in world space (persistent mode)');
          }
          
          hideThrowHint();
        });
      }

      function spawnAndLockObjects() {
        console.log('%cüîß Spawning and locking objects...', 'color: #9C27B0; font-size: 14px;');
        
        const marker = worldTrackingState.markerEl;
        const worldAnchor = worldTrackingState.worldAnchor;
        
        const persistentGroup = document.createElement('a-entity');
        persistentGroup.setAttribute('id', 'persistent-group');
        
        const markerWorldPosition = new THREE.Vector3();
        const markerWorldQuaternion = new THREE.Quaternion();
        const markerWorldScale = new THREE.Vector3();
        
        marker.object3D.updateMatrixWorld();
        marker.object3D.matrixWorld.decompose(
          markerWorldPosition,
          markerWorldQuaternion,
          markerWorldScale
        );
        
        console.log('üìç Captured marker world position:', markerWorldPosition);
        
        persistentGroup.object3D.position.copy(markerWorldPosition);
        persistentGroup.object3D.quaternion.copy(markerWorldQuaternion);
        persistentGroup.object3D.scale.copy(markerWorldScale);
        
        cloneMarkerContents(marker, persistentGroup);
        
        worldAnchor.appendChild(persistentGroup);
        
        marker.object3D.visible = false;
        
        worldTrackingState.hasSpawned = true;
        worldTrackingState.isLocked = true;
        worldTrackingState.persistentGroup = persistentGroup;
        
        console.log('%c‚ú® Objects locked in world space!', 'color: #4CAF50; font-size: 16px; font-weight: bold;');
        
        if (typeof updateThrowIndicator !== 'undefined') {
          updateThrowIndicator('‚úÖ Bins anchored!', 'rgba(76, 175, 80, 0.9)');
        }
        
        setTimeout(() => {
          showRecenterButton();
          setupBinClickHandlers();
        }, 2000);
      }

      function cloneMarkerContents(sourceMarker, targetGroup) {
        console.log('üìã Cloning marker contents...');
        
        const children = Array.from(sourceMarker.children);
        
        children.forEach(child => {
          if (child.id === 'trash-display') return;
          
          const clone = child.cloneNode(true);
          
          if (child.object3D) {
            clone.object3D.position.copy(child.object3D.position);
            clone.object3D.rotation.copy(child.object3D.rotation);
            clone.object3D.scale.copy(child.object3D.scale);
          }
          
          targetGroup.appendChild(clone);
          
          console.log('  ‚úì Cloned:', child.tagName, child.className || '');
        });
        
        console.log('‚úÖ All objects cloned to world space');
        
        setTimeout(() => {
          if (typeof setupBinClickHandlers !== 'undefined') {
            console.log('üîÑ Re-initializing bin click handlers for cloned bins...');
            setupBinClickHandlers();
          }
        }, 500);
      }

      function setupRecenterButton() {
        const btn = worldTrackingState.recenterBtn;
        if (!btn) return;
        
        btn.addEventListener('click', () => {
          console.log('üîÑ Recenter requested...');
          recenterObjects();
        });
      }

      function showRecenterButton() {
        const btn = worldTrackingState.recenterBtn;
        if (btn) {
          btn.classList.remove('hidden');
          console.log('üëÜ Recenter button shown');
        }
      }

      function hideRecenterButton() {
        const btn = worldTrackingState.recenterBtn;
        if (btn) {
          btn.classList.add('hidden');
        }
      }

      function recenterObjects() {
        if (typeof gameState !== 'undefined' && !gameState.isMarkerVisible) {
          if (typeof updateThrowIndicator !== 'undefined') {
            updateThrowIndicator('‚ö†Ô∏è Scan marker to recenter!', 'rgba(244, 67, 54, 0.9)');
          }
          console.log('‚ö†Ô∏è Cannot recenter - marker not visible');
          return;
        }
        
        console.log('%cüîÑ RECENTERING OBJECTS...', 'color: #2196F3; font-size: 14px; font-weight: bold;');
        
        if (worldTrackingState.persistentGroup) {
          worldTrackingState.persistentGroup.parentNode.removeChild(worldTrackingState.persistentGroup);
        }
        
        worldTrackingState.markerEl.object3D.visible = true;
        
        worldTrackingState.hasSpawned = false;
        worldTrackingState.isLocked = false;
        worldTrackingState.persistentGroup = null;
        
        setTimeout(() => {
          spawnAndLockObjects();
          if (typeof updateThrowIndicator !== 'undefined') {
            updateThrowIndicator('‚úÖ Position updated!', 'rgba(76, 175, 80, 0.9)');
          }
        }, 100);
      }

      function getPersistentObjectsContainer() {
        if (worldTrackingState.isLocked && worldTrackingState.persistentGroup) {
          return worldTrackingState.persistentGroup;
        }
        return worldTrackingState.markerEl;
      }

      function showThrowHint() {
        const indicator = document.getElementById('throw-indicator');
        if (indicator) indicator.classList.remove('hidden');
        const btn = document.getElementById('recenter-btn');
        if (btn) btn.classList.remove('hidden');
      }

      function hideThrowHint() {
        const indicator = document.getElementById('throw-indicator');
        if (indicator) indicator.classList.add('hidden');
      }

      let currentScore = 0;
      let currentTrashType = null;

      const gameState = {
        score: 0,
        sceneReady: false,
        isMarkerVisible: false
      };

      const scoreEl = document.getElementById('score-display');
      const feedbackEl = document.getElementById('feedback');
      const trashHolder = document.getElementById('trash-holder');
      const instructionEl = document.getElementById('instruction');

      const trashConfig = {
        kertas: { model: '#trash-kertas-asset', scale: '0.5 0.5 0.5' },
        organik: { model: '#trash-organik-asset', scale: '0.5 0.5 0.5' },
        anorganik: { model: '#trash-anorganik-asset', scale: '0.5 0.5 0.5' }
      };

      const scene = document.querySelector('a-scene');

      scene.addEventListener('loaded', () => {
        console.log('‚úÖ Scene loaded!');
        gameState.sceneReady = true;
        
        initWorldAnchorSystem();
        
        setTimeout(() => {
          console.log('üîß Setting up bin handlers...');
          setupBinClickHandlers();
        }, 1000);
        
        setTimeout(() => {
          setupBinClickHandlers();
        }, 3000);
        
        logInstructions();
      });

      function setupBinClickHandlers() {
        console.log('üîç Looking for bin models...');
        
        const bins = document.querySelectorAll('.bin-model');
        console.log(`üóëÔ∏è Found ${bins.length} bin models`);
        
        const allGltfModels = document.querySelectorAll('a-gltf-model');
        console.log(`üì¶ Found ${allGltfModels.length} total a-gltf-model elements`);
        
        const binModels = Array.from(allGltfModels).filter(model => {
          return model.getAttribute('data-bin-type') !== null;
        });
        console.log(`üéØ Found ${binModels.length} models with data-bin-type`);
        
        if (binModels.length === 0) {
          console.error('‚ùå No bin models found! Retrying...');
          setTimeout(setupBinClickHandlers, 2000);
          return;
        }
        
        binModels.forEach(bin => {
          const binType = bin.getAttribute('data-bin-type');
          console.log(`  üìç Setting up bin: ${binType}`);
          
          bin.removeEventListener('click', bin._clickHandler);
          bin.removeEventListener('mousedown', bin._mouseHandler);
          bin.removeEventListener('touchstart', bin._touchHandler);
          
          bin._clickHandler = (e) => {
            console.log('üñ±Ô∏è CLICK on bin:', binType);
            e.stopPropagation();
            e.preventDefault();
            handleBinClick(binType);
          };
          
          bin._mouseHandler = (e) => {
            console.log('üñ±Ô∏è MOUSEDOWN on bin:', binType);
            e.stopPropagation();
            e.preventDefault();
            handleBinClick(binType);
          };
          
          bin._touchHandler = (e) => {
            console.log('üëÜ TOUCHSTART on bin:', binType);
            e.stopPropagation();
            e.preventDefault();
            handleBinClick(binType);
          };
          
          bin.addEventListener('click', bin._clickHandler);
          bin.addEventListener('mousedown', bin._mouseHandler);
          bin.addEventListener('touchstart', bin._touchHandler, { passive: false });
          
          console.log(`  ‚úÖ Handlers attached to ${binType}`);
        });
        
        console.log('‚úÖ Bin click handlers initialized');
      }

      function spawnTrash(type) {
        trashHolder.innerHTML = '';
        currentTrashType = type;
        
        const config = trashConfig[type];
        const el = document.createElement('a-entity');
        el.setAttribute('gltf-model', config.model);
        el.setAttribute('scale', config.scale);
        el.setAttribute('rotation', '0 45 0');
        el.setAttribute('animation', 'property: position; dir: alternate; dur: 1000; easing: easeInOutSine; loop: true; to: 0 -0.45 -1');
        
        trashHolder.appendChild(el);
        instructionEl.innerText = "Now tap the matching bin!";
        
        updateThrowIndicator('‚úÖ Trash selected! Click correct bin!', 'rgba(76, 175, 80, 0.9)');
      }

      function handleBinClick(binType) {
        console.log('üéØ handleBinClick:', binType);
        
        if (!currentTrashType) {
          alert("Please select a trash type first!");
          updateThrowIndicator('‚ö†Ô∏è Select trash type first!', 'rgba(255, 152, 0, 0.9)');
          return;
        }
        
        throwTrashToBin(binType);
      }

      function throwTrashToBin(targetBinId) {
        const trashEl = trashHolder.firstElementChild;
        if (!trashEl) return;

        trashHolder.innerHTML = '';

        const projectile = document.createElement('a-entity');
        projectile.setAttribute('gltf-model', trashConfig[currentTrashType].model);
        projectile.setAttribute('scale', '0.5 0.5 0.5');
        
        const camera = document.querySelector('a-entity[camera]').object3D;
        const startPos = new THREE.Vector3();
        camera.getWorldPosition(startPos);
        const dir = new THREE.Vector3(0, 0, -1);
        dir.applyQuaternion(camera.quaternion);
        startPos.add(dir);
        
        projectile.setAttribute('position', `${startPos.x} ${startPos.y} ${startPos.z}`);
        
        const targetBin = document.querySelector(`[data-bin-type="${targetBinId}"]`);
        if (!targetBin) {
          console.error('Target bin not found:', targetBinId);
          return;
        }
        
        const targetPos = new THREE.Vector3();
        targetBin.object3D.getWorldPosition(targetPos);
        targetPos.y += 0.5;

        document.querySelector('a-scene').appendChild(projectile);

        projectile.setAttribute('animation', `property: position; to: ${targetPos.x} ${targetPos.y} ${targetPos.z}; dur: 800; easing: easeInQuad`);
        projectile.setAttribute('animation__rot', `property: rotation; to: 720 360 0; dur: 800; easing: linear`);

        setTimeout(() => {
          if (projectile.parentNode) projectile.parentNode.removeChild(projectile);
          
          if (currentTrashType === targetBinId) {
            handleSuccess();
          } else {
            handleFail();
          }
          currentTrashType = null;
          instructionEl.innerText = "Choose another trash type!";
        }, 800);
      }

      function handleSuccess() {
        currentScore += 10;
        gameState.score += 10;
        updateScore();
        showFeedback('CORRECT! +10', 'correct');
        updateThrowIndicator('üéâ CORRECT! +10 Points!', 'rgba(76, 175, 80, 0.9)');
      }

      function handleFail() {
        currentScore -= 5;
        gameState.score -= 5;
        updateScore();
        showFeedback('WRONG! -5', 'wrong');
        updateThrowIndicator('‚ùå WRONG! Try again!', 'rgba(244, 67, 54, 0.9)');
      }

      function updateScore(points) {
        if (scoreEl) {
          scoreEl.textContent = `Score: ${currentScore}`;
          scoreEl.style.color = '#4CAF50';
          setTimeout(() => {
            scoreEl.style.color = 'white';
          }, 500);
        }
      }

      function showFeedback(text, type) {
        feedbackEl.innerText = text;
        feedbackEl.className = `feedback show ${type}`;
        setTimeout(() => {
          feedbackEl.className = 'feedback';
        }, 1500);
      }
      
      function updateThrowIndicator(message, backgroundColor) {
        const throwIndicator = document.getElementById('throw-indicator');
        if (!throwIndicator) return;
        
        throwIndicator.textContent = message;
        throwIndicator.style.background = backgroundColor;
        throwIndicator.classList.remove('hidden');
      }

      function logInstructions() {
        console.log('%cüéØ AR Trash Sorting Game Loaded!', 'color: #4CAF50; font-size: 20px; font-weight: bold;');
        console.log('%cInstructions:', 'color: #2196F3; font-size: 14px;');
        console.log('1. Scan the target marker');
        console.log('2. Select trash type');
        console.log('3. Click the correct bin');
        console.log('4. Paper‚ÜíBlue, Organic‚ÜíGreen, Inorganic‚ÜíRed');
        console.log('%cüåç WORLD ANCHOR: Bins stay in place!', 'color: #FF9800; font-weight: bold;');
      }

      window.worldTrackingState = worldTrackingState;
      window.initWorldAnchorSystem = initWorldAnchorSystem;
      window.getPersistentObjectsContainer = getPersistentObjectsContainer;
      window.recenterObjects = recenterObjects;
    </script>
  </body>
</html>
